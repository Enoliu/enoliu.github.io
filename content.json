{"meta":{"title":"醋溜折耳根","subtitle":"","description":"","author":"Enoliu","url":"https://enoliu.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-07-06T06:26:11.104Z","updated":"2022-07-06T06:26:11.104Z","comments":false,"path":"/404.html","permalink":"https://enoliu.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-06T08:06:01.820Z","updated":"2022-07-06T08:06:01.820Z","comments":false,"path":"about/me.html","permalink":"https://enoliu.github.io/about/me.html","excerpt":"","text":"12345678910111213141516171819202122232425262728&#123; name: &#x27;Enoliu&#x27; age: &#x27;unkonw&#x27;, gender: &#x27;男&#x27;, profession: &#x27;Web Developer &amp; Golanger &amp; PHPer&#x27;, experience: &#x27;5年&#x27;, address: &#x27;四川省成都市&#x27;, education: &#x27;本科&#x27;, github: &#x27;https://github.com/Enoliu&#x27;, blog: &#x27;https://enoliu.github.io.git&#x27;, description: &#x27;欲诚其意者，先致其知，致知在格物&#x27;, skills: [ [&#x27;Html&#x27;, &#x27;Javascript&#x27;, &#x27;jQuery&#x27;, &#x27;CSS&#x27;, &#x27;ES6&#x27;, &#x27;Vue&#x27;], [&#x27;PHP&#x27;, &#x27;Swoole&#x27;, &#x27;Golang&#x27;], [&#x27;Laravel&#x27;,&#x27;Hyperf&#x27;, &#x27;Gin&#x27;], [&#x27;Git&#x27;, &#x27;SVN&#x27;], [&#x27;Redis&#x27;, &#x27;Mysql&#x27;, &#x27;RabbitMQ&#x27;, &#x27;...&#x27;], ], devTools: [ [&#x27;Sublime Text&#x27;, &#x27;Visual Studio Code&#x27;, &#x27;Notepad++&#x27;], [&#x27;Chrome DevTools&#x27;, &#x27;Fiddler&#x27;], [&#x27;SourceTree&#x27;, &#x27;TortoiseSVN&#x27;], [&#x27;SwitchHosts&#x27;], [&#x27;Navicat&#x27;, &#x27;XAMPP&#x27;], ] &#125;"},{"title":"分类","date":"2022-07-06T06:26:11.105Z","updated":"2022-07-06T06:26:11.105Z","comments":false,"path":"categories/index.html","permalink":"https://enoliu.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-06T06:26:11.107Z","updated":"2022-07-06T06:26:11.107Z","comments":false,"path":"tags/index.html","permalink":"https://enoliu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"golang-jwt/jwt使用手册","slug":"golang-jwt-jwt使用手册","date":"2022-08-11T06:06:09.000Z","updated":"2022-08-11T08:58:37.305Z","comments":true,"path":"2022/08/11/golang-jwt-jwt使用手册/","link":"","permalink":"https://enoliu.github.io/2022/08/11/golang-jwt-jwt%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"","text":"安装当前最新版本为v4版本，新增了 Go 模块支持，但依旧保留了向后兼容性 1go get -u github.com/golang-jwt/jwt/v4 官方规定的一些声明Claims（载荷）这些声明都是可选的，不强制的。只是为后续操作提供方便，可操作性的起始点数据 12345678910111213141516171819202122type RegisteredClaims struct &#123; // the `iss` (Issuer) claim. 发行人：声明JWT的发行主体，一般固定为应用名称 Issuer string `json:&quot;iss,omitempty&quot;` // the `sub` (Subject) claim. 主题：声明JWT的发行主题，主题值必须全局惟一的 Subject string `json:&quot;sub,omitempty&quot;` // the `aud` (Audience) claim. 接收者：具体的客户端应用 Audience ClaimStrings `json:&quot;aud,omitempty&quot;` // the `exp` (Expiration Time) claim. 到期时间 ExpiresAt *NumericDate `json:&quot;exp,omitempty&quot;` // the `nbf` (Not Before) claim. 可用开始时间 NotBefore *NumericDate `json:&quot;nbf,omitempty&quot;` // the `iat` (Issued At) claim. 颁发时间 IssuedAt *NumericDate `json:&quot;iat,omitempty&quot;` // the `jti` (JWT ID) claim. JWT的唯一标识符，注意：和sub是不一样的概念 ID string `json:&quot;jti,omitempty&quot;`&#125; 对称加密（例如 HSA）仅使用一个密钥。这可能是最简单的签名方法，因为任何[]byte都可以用作有效的秘密。它们在计算上的使用速度也略快一些，尽管这很少有关系。当令牌的生产者和消费者都受信任，甚至是同一个系统时，对称签名方法效果最好。由于相同的密钥用于签名和验证令牌，因此您无法轻松分发密钥以进行验证。 代码实现生成token1234567891011121314151617181920212223242526272829303132const signKey = &quot;this is your sign key&quot;// CustomClaims 自定义jwt的claims信息，包含官方注册的claimstype CustomClaims struct &#123; jwt.RegisteredClaims Email string `json:&quot;email&quot;`&#125;// CreateToken Create a jwt token from request.func (*helloApi) CreateToken(r *ghttp.Request) &#123; nowTime := time.Now() userId := &quot;123456&quot; // 用户ID（唯一标识） appName := &quot;coolcar&quot; // 应用名称 expireIn := 7 * 24 * time.Hour // 有效时长 var token = jwt.NewWithClaims(jwt.SigningMethodHS256, CustomClaims&#123; RegisteredClaims: jwt.RegisteredClaims&#123; Issuer: appName, Subject: userId, ExpiresAt: jwt.NewNumericDate(nowTime.Add(expireIn)), NotBefore: jwt.NewNumericDate(nowTime), IssuedAt: jwt.NewNumericDate(nowTime), &#125;, Email: &quot;595929049@qq.com&quot;, // 自定义的claims &#125;) tokenString, _ := token.SignedString([]byte(signKey)) _ = r.Response.WriteJson(g.Map&#123; &quot;token&quot;: tokenString, &quot;expire_in&quot;: int(expireIn.Seconds()), &#125;)&#125; 使用token12345678910111213141516171819202122232425262728func (*helloApi) ParseToken(r *ghttp.Request) &#123; tokenString := r.GetHeader(&quot;authorization&quot;) // 注意区分strings.TrimPrefix 和 strings.TrimLeft的区别 tokenString = strings.TrimPrefix(tokenString, &quot;Bearer &quot;) // 加入claims的验证 token, err := jwt.ParseWithClaims(tokenString, &amp;CustomClaims&#123;&#125;, func(token *jwt.Token) (interface&#123;&#125;, error) &#123; return []byte(signKey), nil &#125;) claims, ok := token.Claims.(*CustomClaims) if !ok || !token.Valid &#123; if errors.Is(err, jwt.ErrTokenMalformed) &#123; r.Response.WriteExit(&quot;That&#x27;s not even a token&quot;) &#125; else if errors.Is(err, jwt.ErrTokenExpired) || errors.Is(err, jwt.ErrTokenNotValidYet) &#123; // Token is either expired or not active yet r.Response.WriteExit(&quot;Timing is everything&quot;) &#125; else &#123; r.Response.WriteExit(&quot;Couldn&#x27;t handle this token:&quot;, err) &#125; &#125; _ = r.Response.WriteJson(g.Map&#123; &quot;email&quot;: claims.Email, &quot;user_id&quot;: claims.Subject, &quot;app_name&quot;: claims.Issuer, &#125;)&#125; 非对称加密（例如 RSA）使用不同的密钥来签名和验证令牌。这使得使用私钥生成令牌成为可能，并允许任何消费者访问公钥进行验证。 代码实现生成token1234567891011121314151617181920212223242526272829303132333435363738394041424344const privateKey = `-----BEGIN PRIVATE KEY-----MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAs57i3yugK3vbC6G2UVTw8Vk7BMARaSN1W6ouF59X2N/8ocMbchNxofEudf/2X6Us2V1srFgvPC/CE1N2ncDMXwIDAQABAkAT6VwbAzoJN/yrSGzujSz8hDi/qQ8FCbI7zBy576cMWnCKFwTTKDWfxaW9sISqsiHFoBiq0EHj99H0/x6o014pAiEA4g7yxcu2m6yOQSlaWsA9vHndvuhrPcgXWQfQTqDGodUCIQDLaVrbH4H71uV/svegy4dG8T7U4c8/mil3x9qOowPbYwIhALn7DmUIyn2dI5Qcj4emLaSIppTP5pr3qa3HretifsjZAiBHkdsw7CYdCSCYzMyKG/KOCIX1+zmjhEeA6KXCuCK8RwIgC2synVWxCtKMJdj782Ksw5+rh8fM56SitmgaHfusqJw=-----END PRIVATE KEY-----`// CustomClaims 自定义jwt的claims信息，包含官方注册的claimstype CustomClaims struct &#123; jwt.RegisteredClaims Email string `json:&quot;email&quot;` // 自定义的claims&#125;// CreateToken Create a jwt token from request.func (*helloApi) CreateToken(r *ghttp.Request) &#123; nowTime := time.Now() userId := &quot;123456&quot; // 用户ID（唯一标识） appName := &quot;coolcar&quot; // 应用名称 expireIn := 7 * 24 * time.Hour // 有效时长 var token = jwt.NewWithClaims(jwt.SigningMethodRS256, CustomClaims&#123; RegisteredClaims: jwt.RegisteredClaims&#123; Issuer: appName, Subject: userId, ExpiresAt: jwt.NewNumericDate(nowTime.Add(expireIn)), NotBefore: jwt.NewNumericDate(nowTime), IssuedAt: jwt.NewNumericDate(nowTime), &#125;, Email: &quot;595929049@qq.com&quot;, // 自定义的claims &#125;) privateKey, err := jwt.ParseRSAPrivateKeyFromPEM([]byte(privateKey)) if err != nil &#123; log.Fatal(&quot;parse rsa private key error :&quot;, err) &#125; tokenString, _ := token.SignedString(privateKey) _ = r.Response.WriteJson(g.Map&#123; &quot;token&quot;: tokenString, &quot;expire_in&quot;: int(expireIn.Seconds()), &#125;)&#125; 结果1234&#123; &quot;expire_in&quot;: 604800, &quot;token&quot;: &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJjb29sY2FyIiwic3ViIjoiMTIzNDU2IiwiZXhwIjoxNjYwODA2OTYzLCJuYmYiOjE2NjAyMDIxNjMsImlhdCI6MTY2MDIwMjE2MywiZW1haWwiOiI1OTU5MjkwNDlAcXEuY29tIn0.cr4KPReapVGyiFjmNqGPEIIUrFLSO8PgpoWVFmMnWEzFzd9RBpwJdSLywcE5k7nrwpR9TexPk-hRnxgBta3t5w&quot;&#125; 使用token12345678910111213141516171819202122232425262728293031323334353637const publicKey = `-----BEGIN PUBLIC KEY-----MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALOe4t8roCt72wuhtlFU8PFZOwTAEWkjdVuqLhefV9jf/KHDG3ITcaHxLnX/9l+lLNldbKxYLzwvwhNTdp3AzF8CAwEAAQ==-----END PUBLIC KEY-----`func (*helloApi) ParseToken(r *ghttp.Request) &#123; tokenString := r.GetHeader(&quot;authorization&quot;) // 注意区分strings.TrimPrefix 和 strings.TrimLeft的区别 tokenString = strings.TrimPrefix(tokenString, &quot;Bearer &quot;) //token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface&#123;&#125;, error) &#123; // return jwt.ParseRSAPublicKeyFromPEM([]byte(publicKey)) //&#125;) // 加入claims的验证 token, err := jwt.ParseWithClaims(tokenString, &amp;CustomClaims&#123;&#125;, func(token *jwt.Token) (interface&#123;&#125;, error) &#123; return jwt.ParseRSAPublicKeyFromPEM([]byte(publicKey)) &#125;) claims, ok := token.Claims.(*CustomClaims) if !ok || !token.Valid &#123; if errors.Is(err, jwt.ErrTokenMalformed) &#123; r.Response.WriteExit(&quot;That&#x27;s not even a token&quot;) &#125; else if errors.Is(err, jwt.ErrTokenExpired) || errors.Is(err, jwt.ErrTokenNotValidYet) &#123; // Token is either expired or not active yet r.Response.WriteExit(&quot;Timing is everything&quot;) &#125; else &#123; r.Response.WriteExit(&quot;Couldn&#x27;t handle this token:&quot;, err) &#125; &#125; _ = r.Response.WriteJson(g.Map&#123; &quot;email&quot;: claims.Email, &quot;user_id&quot;: claims.Subject, &quot;app_name&quot;: claims.Issuer, &#125;)&#125; 结果12345&#123; &quot;app_name&quot;: &quot;coolcar&quot;, &quot;email&quot;: &quot;595929049@qq.com&quot;, &quot;user_id&quot;: &quot;123456&quot;&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://enoliu.github.io/categories/Golang/"}],"tags":[{"name":"jwt","slug":"jwt","permalink":"https://enoliu.github.io/tags/jwt/"}]},{"title":"[golang]grpc-gateway使用入门","slug":"golang-grpc-gateway使用入门","date":"2022-07-22T06:10:08.000Z","updated":"2022-07-22T08:40:08.087Z","comments":true,"path":"2022/07/22/golang-grpc-gateway使用入门/","link":"","permalink":"https://enoliu.github.io/2022/07/22/golang-grpc-gateway%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/","excerpt":"","text":"gRPC-Gateway介绍gRPC简单实现 定义proto文件 123456789101112131415161718192021222324252627282930syntax = &quot;proto3&quot;;package auth.v1;option go_package = &quot;coolcar/auth/api/gen/v1;authpb&quot;;// import &quot;google/api/annotations.proto&quot;;service AuthService &#123; // 注解方式 // rpc Login (LoginRequest) returns (LoginResponse) &#123; // option(google.api.http) = &#123; // post: &quot;/v1/auth/login&quot;, // body: &quot;*&quot; // &#125;; // &#125;; // 也可以通过auth.yaml配置文件形式 rpc Login (LoginRequest) returns (LoginResponse);&#125;message LoginRequest &#123; string code = 1;&#125;message LoginResponse &#123; string access_token = 1; int32 expires_in = 2;&#125; 根据文件生成相应代码 12345678910111213141516# go程序代码protoc -I . --go_out gen/v1 --go_opt paths=source_relative auth.proto# grpc服务代码protoc -I . --go-grpc_out gen/v1 --go-grpc_opt paths=source_relative auth.proto# grpc-gateway代码protoc -I . --grpc-gateway_out gen/v1 --grpc-gateway_opt paths=source_relative,grpc_api_configuration=auth.yaml auth.proto# 三个命令可合为一个protoc -I . \\--go_out gen/v1 \\--go_opt paths=source_relative \\--go-grpc_out gen/v1 \\--go-grpc_opt paths=source_relative \\--grpc-gateway_out gen/v1 \\--grpc-gateway_opt paths=source_relative,grpc_api_configuration=auth.yaml \\auth.proto 生成代码文件 1234567├── auth.proto # proto├── auth.yaml # gateway 配置文件└── gen └── v1 ├── auth_grpc.pb.go # grpc服务方法 ├── auth.pb.go # 消息体文件 └── auth.pb.gw.go # grpc-gateway代理文件 实现grpc服务接口方法 12345678910111213141516171819package authimport ( &quot;context&quot; authpb &quot;coolcar/auth/api/gen/v1&quot;)type Service struct &#123; // 不要问，继承这个空服务就行了。看稳定是为了兼容后续 *authpb.UnimplementedAuthServiceServer&#125;func (s *Service) Login(ctx context.Context, req *authpb.LoginRequest) (*authpb.LoginResponse, error) &#123; return &amp;authpb.LoginResponse&#123; AccessToken: &quot;access_token for &quot; + req.Code, ExpiresIn: 7200, &#125;, nil&#125; 拉起grpc服务 12345678910111213141516171819202122232425package mainimport ( authpb &quot;coolcar/auth/api/gen/v1&quot; &quot;coolcar/auth/auth&quot; &quot;log&quot; &quot;net&quot; &quot;google.golang.org/grpc&quot;)func main() &#123; // 监听TCP端口号 lis, err := net.Listen(&quot;tcp&quot;, &quot;:8081&quot;) if err != nil &#123; log.Fatal(err) &#125; // 创建一个grpc服务 s := grpc.NewServer() // 注册grpc服务 authpb.RegisterAuthServiceServer(s, &amp;auth.Service&#123;&#125;) // 拉起服务 log.Fatal(s.Serve(lis))&#125; 调用grpc服务 1234567891011121314151617func startClient() &#123; conn, err := grpc.Dial(&quot;localhost:8081&quot;, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil &#123; log.Fatalln(&quot;连接服务失败:&quot;, err) &#125; defer conn.Close() client := authpb.NewAuthServiceClient(conn) ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() rsp, err := client.Login(ctx, &amp;authpb.LoginRequest&#123;Code: &quot;123456&quot;&#125;) if err != nil &#123; log.Fatalln(&quot;调用方法失败：&quot;, err) &#125; fmt.Printf(&quot;调用结果为: access_token = %v, expire_in = %v&quot;, rsp.AccessToken, rsp.ExpiresIn)&#125; 为gRPC服务添加Gateway前端程序不能直接调用grpc服务，所以使用grpc-gateway网关反向代理 方式一123456789101112131415161718192021222324252627282930313233343536func registerHandler() &#123; // 创建一个客户端连接到grpc服务器，然后用grpc-gateway代理请求反向代理到这个客户端 conn, err := grpc.DialContext( context.Background(), &quot;localhost:8081&quot;, grpc.WithBlock(), grpc.WithTransportCredentials(insecure.NewCredentials()), ) if err != nil &#123; log.Fatalln(&quot;连接grpc服务器失败&quot;, err) &#125; // 创建路由处理器 gwmux := runtime.NewServeMux(runtime.WithMarshalerOption( runtime.MIMEWildcard, &amp;runtime.JSONPb&#123; MarshalOptions: protojson.MarshalOptions&#123; Multiline: false, // 多行显示，Indent Indent: &quot;&quot;, // 缩进 AllowPartial: false, UseProtoNames: false, // 使用原型proto里定义的字段名 UseEnumNumbers: false, // 使用枚举enum对应的数字 EmitUnpopulated: false, // 是否返回空（未填充）的字段 Resolver: nil, &#125;, &#125;, )) err = authpb.RegisterAuthServiceHandler(context.Background(), gwmux, conn) if err != nil &#123; log.Fatal(&quot;注册grpc-gateway代理失败：&quot;, err) &#125; // 监听http服务 log.Fatal(&quot;启动http服务失败:&quot;, http.ListenAndServe(&quot;:8080&quot;, gwmux))&#125; 方式二12345678910111213141516171819202122232425262728293031323334353637func registerHandlerFromEndPoint() &#123; ctx, cancel := context.WithCancel(context.Background()) defer cancel() // 创建路由处理器 gwmux := runtime.NewServeMux(runtime.WithMarshalerOption( runtime.MIMEWildcard, // JSONPb对JSON进行编组/解组。与JSONBuiltin不同，它支持protobuf的全部功能。 &amp;runtime.JSONPb&#123; MarshalOptions: protojson.MarshalOptions&#123; // Multiline: false, // 多行显示，Indent // Indent: &quot;&quot;, // 缩进 // AllowPartial: false, UseProtoNames: true, // 使用原型proto里定义的字段名 UseEnumNumbers: true, // 使用枚举enum对应的数字 EmitUnpopulated: true, // 是否返回空（未填充）的字段 // Resolver: nil, &#125;, &#125;, )) // 注册服务 err := authpb.RegisterAuthServiceHandlerFromEndpoint(ctx, gwmux, &quot;localhost:8081&quot;, []grpc.DialOption&#123; grpc.WithBlock(), grpc.WithTransportCredentials(insecure.NewCredentials()), &#125;) if err != nil &#123; log.Fatalln(&quot;注册服务失败&quot;, err) &#125; // 监听http服务 err = http.ListenAndServe(&quot;:8080&quot;, gwmux) if err != nil &#123; log.Fatal(&quot;启动http服务失败:&quot;, err) &#125;&#125; 发起http请求1234567891011121314curl -X POST \\ &#x27;http://127.0.0.1:8080/v1/auth/login&#x27; \\ --header &#x27;Accept: */*&#x27; \\ --header &#x27;User-Agent: Thunder Client (https://www.thunderclient.com)&#x27; \\ --header &#x27;Content-Type: application/json&#x27; \\ --data-raw &#x27;&#123; &quot;code&quot;: &quot;123&quot;&#125;&#x27;#返回&#123; &quot;accessToken&quot;: &quot;access_token for 123&quot;, &quot;expiresIn&quot;: 7200&#125; gRPC-Gateway代理配置 注解方式(google.api.http)需要加入依赖文件googleapis1234567proto├── google│ └── api│ ├── annotations.proto│ └── http.proto└── helloworld └── hello_world.proto protobuf 文件修改加入注解1234567891011121314151617181920212223242526syntax = &quot;proto3&quot;;package helloworld;import &quot;google/api/annotations.proto&quot;;// Here is the overall greeting service definition where we define all our endpointsservice Greeter &#123; // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) &#123; option (google.api.http) = &#123; post: &quot;/v1/example/echo&quot; body: &quot;*&quot; &#125;; &#125;&#125;// The request message containing the user&#x27;s namemessage HelloRequest &#123; string name = 1;&#125;// The response message containing the greetingsmessage HelloReply &#123; string message = 1;&#125; yaml配置文件文档地址：https://grpc-ecosystem.github.io/grpc-gateway/docs/mapping/grpc_api_configuration/12345678type: google.api.Serviceconfig_version: 3http: rules: - selector: your.service.v1.YourService.Echo post: /v1/example/echo body: &quot;*&quot;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://enoliu.github.io/categories/Golang/"}],"tags":[{"name":"protobuf","slug":"protobuf","permalink":"https://enoliu.github.io/tags/protobuf/"},{"name":"grpc","slug":"grpc","permalink":"https://enoliu.github.io/tags/grpc/"},{"name":"grpc-gateway","slug":"grpc-gateway","permalink":"https://enoliu.github.io/tags/grpc-gateway/"}]},{"title":"golang-protobuf入门记录","slug":"golang-protobuf入门记录","date":"2022-07-15T02:19:25.000Z","updated":"2022-07-15T07:06:28.081Z","comments":true,"path":"2022/07/15/golang-protobuf入门记录/","link":"","permalink":"https://enoliu.github.io/2022/07/15/golang-protobuf%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"语法指南1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 语法标记，默认为proto2语法// 必须位于文件开头非空非注释的第一行syntax = &quot;proto3&quot;;// 以包声明开头，这有助于防止不同项目之间的命名冲突。package coolcar;// go_package选项定义了包的导入路径，该路径将包含此文件的所有生成代码。Go 包名称将是导入路径的最后一个路径组件option go_package=&quot;coolcar/proto/gen/go/trippb&quot;;// 消息体// 消息体内每个字段都由一个字段类型、字段名称、字段编号组成// 字段类型：float,int32,int64,uint32,uint64,bool,string,bytes,nested type(复合类型或嵌套类型)// 字段编号：1~15编号使用一个字节编码，16~2047范围两个编码，因此应该为非常频繁出现的消息元素保留数字 1 到 15// 数字 19000 到 19999是为 Protocol Buffers 实现保留的，不能使用// 字段名称：使用小写加下划线，计量字段因带上计量单位，如：duration_sec(时长：秒)，fee_cent(费用：分)// 保留字段：如果需要更新功能时可以通过 reserved 保留某些字段名称或字段编号，这样就不会被重新使用了，protoc会检查。message Location &#123; float latitude = 1; float longitude = 2;&#125;// 枚举// 必须有一个零值，用于使用0作为默认数字// 零值必须为第一个元素，以便与proto2语法兼容// 通过设置 option allow_alias = true; 来为不同的枚举设置同样的值：如SUCCESS// 常量数字必须在32位整数内，不推荐使用负数（编码低效）// 枚举可以定义在消息体类，也可以在外面// 保留字段：如果需要更新功能时可以通过 reserved 保留某些枚举字段或枚举常量，这样就不会被重新使用了，protoc会检查。enum TripStatus &#123; // option allow_alias = true; TS_NOT_SPECIFIED = 0; NOT_STARTED = 1; IN_PROGRESS = 2; FINISHED = 3; PAID = 4; // SUCCESS = 4;&#125;// 使用其他消息类型// repeated 用于一个字段保存多个数据// 关联映射 map&lt;string, Project&gt; projects = 3; map字段不能是repeatedmessage Trip &#123; string start = 1; string end = 2; Location start_pos = 5; Location end_pos = 6; repeated Location path_locations = 7; int32 duration_sec = 3; int32 fee_cent = 4; TripStatus status = 8; map&lt;string, string&gt; projects = 9;&#125;// 导入定义// import &quot;myproject/other_protos.proto&quot;;message GetTripRequest &#123; string id = 1;&#125;message GetTripResponse &#123; string id = 1; Trip trip = 2;&#125;// 定义RPC服务接口service TripService &#123; rpc GetTrip (GetTripRequest) returns (GetTripResponse);&#125; 编译.proto文件 首先安装protobuf按照系统下载让后安装并加入系统变量12https://github.com/protocolbuffers/protobuf/releases 安装protobuf的golang插件编译器插件protoc-gen-go将安装在 中 $GOBIN123go install google.golang.org/protobuf/cmd/protoc-gen-go@latest#grpc服务需要go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest 运行编译器$SRC_DIR源码目录，不指定则为当前目录。$DST_DIR输出目录1234#格式protoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto#demoprotoc -I=. --go_out=paths=source_relative:gen/go --go-grpc_out=paths=source_relative:gen/go trip.proto –go_out参数说明123456789101112131415161718192021222324--go_out参数用来指定 protoc-gen-go 插件的工作方式和go代码的生成位置--go_out主要的两个参数为 plugins 和 paths，分别表示生成go代码所使用的插件和生成的go代码的位置。--go_out的写法是参数之间用 逗号 隔开，最后加上 冒号 来指定代码的生成位置。比如：--go_out=plugins=grpc,paths=import:.paths参数有两个选项，分别是 import 和 source_relative。默认为 import，表示按照生成的go代码的包的全路径去创建目录层级，source_relative 表示按照proto源文件的目录层级去创建go代码的目录层级。例：option go_package=&quot;proto/pb_go&quot;;# 指令1：paths为import，pb文件最终在 pb_go 目录下$ protoc --proto_path=. --go_out=. proto/greeter/greeter.proto$ protoc --proto_path=. --go_out=paths=import:. proto/greeter/greeter.proto# 指令2：paths为source_relative，pb文件最终在 proto/greeter 目录下$ protoc --proto_path=. --go_out=paths=source_relative:. proto/greeter/greeter.proto plugins参数带grpc时会生成一些跟gRPC相关的代码，实现gRPC通信。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://enoliu.github.io/categories/Golang/"}],"tags":[{"name":"protobuf","slug":"protobuf","permalink":"https://enoliu.github.io/tags/protobuf/"},{"name":"grpc","slug":"grpc","permalink":"https://enoliu.github.io/tags/grpc/"}]},{"title":"[Hyperf]JWT认证与自动刷新token","slug":"[hyperf]jwt认证与自动刷新token","date":"2022-07-07T02:19:25.000Z","updated":"2022-07-07T02:45:40.807Z","comments":true,"path":"2022/07/07/[hyperf]jwt认证与自动刷新token/","link":"","permalink":"https://enoliu.github.io/2022/07/07/[hyperf]jwt%E8%AE%A4%E8%AF%81%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0token/","excerpt":"","text":"Auth组件 安装hyperf-ext&#x2F;auth组件1composer require hyperf-ext/auth 发布配置文件（文件位于 config&#x2F;autoload&#x2F;auth.php）1php bin/hyperf.php vendor:publish hyperf-ext/auth 添加助手方法文件app&#x2F;Functions.php12345678910111213if (! function_exists(&#x27;auth&#x27;)) &#123; /** * Auth认证辅助方法 * @param string|null $guard 守护名称 * @return \\HyperfExt\\Auth\\Contracts\\GuardInterface|\\HyperfExt\\Auth\\Contracts\\StatefulGuardInterface|\\HyperfExt\\Auth\\Contracts\\StatelessGuardInterface */ function auth(string $guard = &#x27;api&#x27;) &#123; if (is_null($guard)) $guard = config(&#x27;auth.default.guard&#x27;); return make(\\HyperfExt\\Auth\\Contracts\\AuthManagerInterface::class)-&gt;guard($guard); &#125;&#125; 加完后记得要用composer自动加载哟 Auth依赖组件 安装hyperf-ext&#x2F;hashing1composer require hyperf-ext/hashing 发布配置（配置文件位于 config&#x2F;autoload&#x2F;hashing.php）1php bin/hyperf.php vendor:publish hyperf-ext/hashing JWT组件 安装hyperf-ext&#x2F;jwt1composer require hyperf-ext/jwt 发布配置文件（文件位于 config&#x2F;autoload&#x2F;jwt.php）1php bin/hyperf.php vendor:publish hyperf-ext/jwt 创建两个数据库迁移文件12php bin/hyperf.php gen:migration create_users_tablephp bin/hyperf.php gen:migration create_administrators_table 两个表内容其实是一样的，用来模拟多守护认证。如下（根据实际需求调整） 12345678910111213141516171819202122232425262728293031use Hyperf\\Database\\Schema\\Schema;use Hyperf\\Database\\Schema\\Blueprint;use Hyperf\\Database\\Migrations\\Migration;class CreateUsersTable extends Migration&#123; /** * Run the migrations. */ public function up(): void &#123; Schema::create(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;bigIncrements(&#x27;id&#x27;); $table-&gt;char(&#x27;username&#x27;, 20)-&gt;default(&#x27;&#x27;)-&gt;comment(&#x27;用户昵称&#x27;); $table-&gt;char(&#x27;password&#x27;, 200)-&gt;default(&#x27;&#x27;)-&gt;comment(&#x27;用户密码&#x27;); $table-&gt;string(&#x27;avatar&#x27;)-&gt;default(&#x27;&#x27;)-&gt;comment(&#x27;用户头像&#x27;); $table-&gt;char(&#x27;email&#x27;, 50)-&gt;default(&#x27;&#x27;)-&gt;unique(&#x27;email&#x27;)-&gt;comment(&#x27;用户邮箱&#x27;); $table-&gt;char(&#x27;phone&#x27;, 15)-&gt;default(&#x27;&#x27;)-&gt;unique(&#x27;phone&#x27;)-&gt;comment(&#x27;用户手机号&#x27;); $table-&gt;timestamps(); &#125;); &#125; /** * Reverse the migrations. */ public function down(): void &#123; Schema::dropIfExists(&#x27;users&#x27;); &#125;&#125; JWT配置 生成jwt key1php bin/hyperf.php gen:jwt-secret 可选（Set the JWT private key and public key used to sign the tokens）1php bin/hyperf.php gen:jwt-keypair .env文件12JWT_BLACKLIST_GRACE_PERIOD=5 设置宽限期（以秒为单位）以防止并发请求失败。JWT_TTL=3600 指定令牌有效的时长（以秒为单位）。默认为 1 小时 4.其他配置基本可以不变(config&#x2F;autoload&#x2F;jwt.php) 添加Auth守护guard123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960declare(strict_types=1);return [ &#x27;default&#x27; =&gt; [ &#x27;guard&#x27; =&gt; &#x27;api&#x27;, // 默认接口api守护 &#x27;passwords&#x27; =&gt; &#x27;users&#x27;, ], &#x27;guards&#x27; =&gt; [ &#x27;web&#x27; =&gt; [ &#x27;driver&#x27; =&gt; \\HyperfExt\\Auth\\Guards\\SessionGuard::class, &#x27;provider&#x27; =&gt; &#x27;users&#x27;, &#x27;options&#x27; =&gt; [], ], // 接口api守护 &#x27;api&#x27; =&gt; [ &#x27;driver&#x27; =&gt; \\HyperfExt\\Auth\\Guards\\JwtGuard::class, &#x27;provider&#x27; =&gt; &#x27;api&#x27;, &#x27;options&#x27; =&gt; [], ], // 管理端admin守护 &#x27;admin&#x27; =&gt; [ &#x27;driver&#x27; =&gt; \\HyperfExt\\Auth\\Guards\\JwtGuard::class, &#x27;provider&#x27; =&gt; &#x27;admin&#x27;, &#x27;options&#x27; =&gt; [], ], ], &#x27;providers&#x27; =&gt; [ &#x27;api&#x27; =&gt; [ &#x27;driver&#x27; =&gt; \\HyperfExt\\Auth\\UserProviders\\ModelUserProvider::class, &#x27;options&#x27; =&gt; [ &#x27;model&#x27; =&gt; \\App\\Model\\User::class, // 用户模型 &#x27;hash_driver&#x27; =&gt; &#x27;bcrypt&#x27;, ], ], &#x27;admin&#x27; =&gt; [ &#x27;driver&#x27; =&gt; \\HyperfExt\\Auth\\UserProviders\\ModelUserProvider::class, &#x27;options&#x27; =&gt; [ &#x27;model&#x27; =&gt; \\App\\Model\\Admin::class, // 管理员模型 &#x27;hash_driver&#x27; =&gt; &#x27;bcrypt&#x27;, ], ] ], &#x27;passwords&#x27; =&gt; [ &#x27;users&#x27; =&gt; [ &#x27;driver&#x27; =&gt; \\HyperfExt\\Auth\\Passwords\\DatabaseTokenRepository::class, &#x27;provider&#x27; =&gt; &#x27;users&#x27;, &#x27;options&#x27; =&gt; [ &#x27;connection&#x27; =&gt; null, &#x27;table&#x27; =&gt; &#x27;password_resets&#x27;, &#x27;expire&#x27; =&gt; 3600, &#x27;throttle&#x27; =&gt; 60, &#x27;hash_driver&#x27; =&gt; null, ], ], ], &#x27;password_timeout&#x27; =&gt; 10800, &#x27;policies&#x27; =&gt; [ //Model::class =&gt; Policy::class, ],]; 更新模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849declare (strict_types=1);namespace App\\Model;use Hyperf\\ModelCache\\Cacheable;use HyperfExt\\Auth\\Authenticatable;use HyperfExt\\Auth\\Contracts\\AuthenticatableInterface;use HyperfExt\\Jwt\\Contracts\\JwtSubjectInterface;/** */class User extends Model implements AuthenticatableInterface ,JwtSubjectInterface&#123; use Authenticatable, Cacheable; /** * The table associated with the model. * * @var string */ protected $table = &#x27;users&#x27;; /** * The attributes that are mass assignable. * * @var array */ protected $fillable = []; /** * The attributes that should be cast to native types. * * @var array */ protected $casts = []; public function getJwtIdentifier() &#123; return $this-&gt;getKey(); &#125; /** * JWT自定义载荷 * @return array */ public function getJwtCustomClaims(): array &#123; return [ &#x27;guard&#x27; =&gt; &#x27;api&#x27; // 添加一个自定义载荷保存守护名称，方便后续判断 ]; &#125;&#125; 使用创建AuthController 1php bin/hyperf.php gen:controller AuthController 内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879declare(strict_types=1);namespace App\\Controller;use App\\Constants\\HttpCode;use App\\Traits\\ApiResponseTrait;use Hyperf\\HttpServer\\Annotation\\Controller;use Hyperf\\HttpServer\\Annotation\\Middleware;use Hyperf\\HttpServer\\Annotation\\Middlewares;use Hyperf\\HttpServer\\Annotation\\RequestMapping;use Hyperf\\HttpServer\\Contract\\RequestInterface;use App\\Middleware\\Auth\\RefreshTokenMiddleware;use HyperfExt\\Jwt\\Contracts\\JwtFactoryInterface;use Psr\\Http\\Message\\ResponseInterface;/** * @Controller(prefix=&quot;auth&quot;) * Class AuthController * @package App\\Controller */class AuthController&#123; use ApiResponseTrait; /** * @RequestMapping(path=&quot;login&quot;, methods=&#123;&quot;POST&quot;&#125;) * @param RequestInterface $request * @return ResponseInterface */ public function login(RequestInterface $request): ResponseInterface &#123; $credentials = $request-&gt;inputs([&#x27;email&#x27;, &#x27;password&#x27;]); if (!$token = auth(&#x27;api&#x27;)-&gt;attempt($credentials)) &#123; return $this-&gt;setHttpCode(HttpCode::UNAUTHORIZED)-&gt;fail(&#x27;Unauthorized&#x27;); &#125; return $this-&gt;respondWithToken($token); &#125; /** * @RequestMapping(path=&quot;user&quot;) * @Middlewares(&#123;@Middleware(RefreshTokenMiddleware::class)&#125;) */ public function me(): ResponseInterface &#123; return $this-&gt;success(auth(&#x27;api&#x27;)-&gt;user()); &#125; /** * @RequestMapping(path=&quot;refresh&quot;, methods=&#123;&quot;GET&quot;&#125;) */ public function refresh(): ResponseInterface &#123; return $this-&gt;respondWithToken(auth(&#x27;api&#x27;)-&gt;refresh()); &#125; /** * @RequestMapping(path=&quot;logout&quot;, methods=&#123;&quot;DELETE&quot;&#125;) */ public function logout(): ResponseInterface &#123; auth(&#x27;api&#x27;)-&gt;logout(); return $this-&gt;success([&#x27;message&#x27; =&gt; &#x27;Successfully logged out&#x27;]); &#125; /** * @param $token * @return ResponseInterface */ protected function respondWithToken($token): ResponseInterface &#123; return $this-&gt;success([ &#x27;access_token&#x27; =&gt; $token, &#x27;token_type&#x27; =&gt; &#x27;bearer&#x27;, &#x27;expire_in&#x27; =&gt; make(JwtFactoryInterface::class)-&gt;make()-&gt;getPayloadFactory()-&gt;getTtl() ]); &#125;&#125; 自动刷新token中间件生成中间件RefreshTokenMiddleware 1php bin/hyperf.php gen:middleware Auth\\\\RefreshTokenMiddleware 内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpdeclare(strict_types=1);namespace App\\Middleware;use App\\Constants\\HttpCode;use App\\Utils\\ApiResponseTrait;use Exception;use Hyperf\\Di\\Annotation\\Inject;use HyperfExt\\Jwt\\Contracts\\ManagerInterface;use HyperfExt\\Jwt\\Exceptions\\TokenExpiredException;use HyperfExt\\Jwt\\JwtFactory;use Psr\\Container\\ContainerInterface;use Psr\\Http\\Message\\ResponseInterface;use Psr\\Http\\Server\\MiddlewareInterface;use Psr\\Http\\Message\\ServerRequestInterface;use Psr\\Http\\Server\\RequestHandlerInterface;class RefreshTokenMiddleware implements MiddlewareInterface&#123; use ApiResponseTrait; /** * @var ContainerInterface */ protected $container; /** * @Inject * @var ManagerInterface */ private $manager; /** * @Inject * @var JwtFactory */ private $jwtFactory; public function __construct(ContainerInterface $container) &#123; $this-&gt;container = $container; &#125; public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface &#123; $jwt = $this-&gt;jwtFactory-&gt;make(); try &#123; $jwt-&gt;checkOrFail(); &#125; catch (Exception $exception) &#123; if (! $exception instanceof TokenExpiredException) &#123; return $this-&gt;setHttpCode(HttpCode::UNPROCESSABLE_ENTITY)-&gt;fail($exception-&gt;getMessage()); &#125; try &#123; $token = $jwt-&gt;getToken(); // 刷新token $new_token = $jwt-&gt;getManager()-&gt;refresh($token); // 解析token载荷信息 $payload = $jwt-&gt;getManager()-&gt;decode($token, false, true); // 旧token加入黑名单 $jwt-&gt;getManager()-&gt;getBlacklist()-&gt;add($payload); // 一次性登录，保证此次请求畅通 auth($payload-&gt;get(&#x27;guard&#x27;) ?? config(&#x27;auth.default.guard&#x27;))-&gt;onceUsingId($payload-&gt;get(&#x27;sub&#x27;)); return $handler-&gt;handle($request)-&gt;withHeader(&#x27;authorization&#x27;, &#x27;bearer &#x27; . $new_token); &#125; catch (Exception $exception) &#123; return $this-&gt;setHttpCode(HttpCode::UNPROCESSABLE_ENTITY)-&gt;fail($exception-&gt;getMessage()); &#125; &#125; return $handler-&gt;handle($request); &#125;&#125; 补充 ApiResponseTrait123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?phpnamespace App\\Traits;use App\\Constants\\HttpCode;use Hyperf\\HttpMessage\\Stream\\SwooleStream;use Hyperf\\Utils\\Codec\\Json;use Hyperf\\Utils\\Context;use Hyperf\\Utils\\Contracts\\Arrayable;use Hyperf\\Utils\\Contracts\\Jsonable;use Psr\\Http\\Message\\ResponseInterface;trait ApiResponseTrait&#123; private $httpCode = HttpCode::OK; private $headers = [ &#x27;Author&#x27; =&gt; &#x27;Colorado&#x27; ]; private $errorCode = 100000; private $errorMsg = &#x27;&#x27;; protected $response; /** * 成功响应 * @param mixed $data * @return ResponseInterface */ public function success($data): ResponseInterface &#123; return $this-&gt;respond($data); &#125; /** * 错误返回 * @param string $err_msg 错误信息 * @param int $err_code 错误业务码 * @param array $data 额外返回的数据 * @return ResponseInterface */ public function fail(string $err_msg = &#x27;&#x27;, int $err_code = 200000, array $data = []): ResponseInterface &#123; return $this-&gt;setHttpCode($this-&gt;httpCode == HttpCode::OK ? HttpCode::BAD_REQUEST : $this-&gt;httpCode) -&gt;respond([ &#x27;err_code&#x27; =&gt; $err_code ?? $this-&gt;errorCode, &#x27;err_msg&#x27; =&gt; $err_msg ?? $this-&gt;errorMsg, &#x27;data&#x27; =&gt; $data ]); &#125; /** * 设置http返回码 * @param int $code http返回码 * @return $this */ final public function setHttpCode(int $code = HttpCode::OK): self &#123; $this-&gt;httpCode = $code; return $this; &#125; /** * 设置返回头部header值 * @param string $key * @param $value * @return $this */ public function addHttpHeader(string $key, $value): self &#123; $this-&gt;headers += [$key =&gt; $value]; return $this; &#125; /** * 批量设置头部返回 * @param array $headers header数组：[key1 =&gt; value1, key2 =&gt; value2] * @return $this */ public function addHttpHeaders(array $headers = []): self &#123; $this-&gt;headers += $headers; return $this; &#125; /** * @param null|array|Arrayable|Jsonable|string $response * @return ResponseInterface */ private function respond($response): ResponseInterface &#123; if (is_string($response)) &#123; return $this-&gt;response()-&gt;withAddedHeader(&#x27;content-type&#x27;, &#x27;text/plain&#x27;)-&gt;withBody(new SwooleStream($response)); &#125; if (is_array($response) || $response instanceof Arrayable) &#123; return $this-&gt;response() -&gt;withAddedHeader(&#x27;content-type&#x27;, &#x27;application/json&#x27;) -&gt;withBody(new SwooleStream(Json::encode($response))); &#125; if ($response instanceof Jsonable) &#123; return $this-&gt;response() -&gt;withAddedHeader(&#x27;content-type&#x27;, &#x27;application/json&#x27;) -&gt;withBody(new SwooleStream((string)$response)); &#125; return $this-&gt;response()-&gt;withAddedHeader(&#x27;content-type&#x27;, &#x27;text/plain&#x27;)-&gt;withBody(new SwooleStream((string)$response)); &#125; /** * @return mixed|ResponseInterface|null */ protected function response(): ResponseInterface &#123; $response = Context::get(ResponseInterface::class); foreach ($this-&gt;headers as $key =&gt; $value) &#123; $response = $response-&gt;withHeader($key, $value); &#125; return $response; &#125;&#125; hyperf新人，老手勿喷，共同研究，一起进步","categories":[{"name":"PHP","slug":"PHP","permalink":"https://enoliu.github.io/categories/PHP/"}],"tags":[{"name":"hyperf","slug":"hyperf","permalink":"https://enoliu.github.io/tags/hyperf/"},{"name":"jwt","slug":"jwt","permalink":"https://enoliu.github.io/tags/jwt/"},{"name":"php","slug":"php","permalink":"https://enoliu.github.io/tags/php/"}]}],"categories":[{"name":"Golang","slug":"Golang","permalink":"https://enoliu.github.io/categories/Golang/"},{"name":"PHP","slug":"PHP","permalink":"https://enoliu.github.io/categories/PHP/"}],"tags":[{"name":"jwt","slug":"jwt","permalink":"https://enoliu.github.io/tags/jwt/"},{"name":"protobuf","slug":"protobuf","permalink":"https://enoliu.github.io/tags/protobuf/"},{"name":"grpc","slug":"grpc","permalink":"https://enoliu.github.io/tags/grpc/"},{"name":"grpc-gateway","slug":"grpc-gateway","permalink":"https://enoliu.github.io/tags/grpc-gateway/"},{"name":"hyperf","slug":"hyperf","permalink":"https://enoliu.github.io/tags/hyperf/"},{"name":"php","slug":"php","permalink":"https://enoliu.github.io/tags/php/"}]}